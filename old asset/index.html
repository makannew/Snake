<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>3D snake game</title>
</head>
<style>
    body {margin: 0 ;};
    canvas {width: 100%; height: 100;};
</style>
<body>
    <script src="js/three.min.js"></script>
    <script src="js/cannon.min.js"></script>
   
    <script>
        //start loading files
        let cubeCharacter = new Array();
        for (let i = 0 ; i <= 8 ; ++i){
            cubeCharacter [ i ] = new CubeObject("characters/" + i.toString(10) + ".png") ;
        }
        //three.js setup
        let scene = new THREE.Scene ();
        let camera = new THREE.PerspectiveCamera ( 50, window.innerWidth / window.innerHeight , 0.1 , 10000);
        let renderer = new THREE.WebGLRenderer ();
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setSize ( window.innerWidth , window.innerHeight);
        window.addEventListener('resize', function () {
            renderer.setSize ( window.innerWidth , window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix ();
        });
        document.body.appendChild ( renderer.domElement );

        //ambient light
        let ambientLight = new THREE.AmbientLight (0xffffff , .5);
        scene.add ( ambientLight );
        //
        let spotLight = new THREE.SpotLight( 0xffffff ,.8);
        spotLight.position.set( 0, 1000, 0 );
        spotLight.target.position.set( 0, 0, 0 );
        spotLight.castShadow = true ;
        scene.add(spotLight);
        spotLight.shadow.mapSize.width = 2048;  // default
        spotLight.shadow.mapSize.height = 2048; // default
        spotLight.shadow.camera.near = 0.5;       // default
        spotLight.shadow.camera.far = 2048;      // default
        spotLight.shadowMapDarkness = 1;

        // //if(true){
        // spotLight.castShadow = true;
        //             // spotLight.shadow.camera.near = 20;
        //             // spotLight.shadow.camera.far = 50;//camera.far;
        //spotLight.shadow.camera.fov = 10;
        //spotLight.shadow.bias = .1;
        //             // spotLight.shadow.mapSize.width = 2*512;
        //             // spotLight.shadow.mapSize.height = 2*512;
        // spotLight.shadow.camera.visible = true;
        //         //}
        // scene.add(spotLight);
        // let pointLight = new THREE.PointLight(0xffffff,1);
        // pointLight.position.set(-300,0,0);
        // scene.add(pointLight);
        //
        // let spotLight = new THREE.SpotLight(0xffffff,1.2);
        // spotLight.position.set(0,100,0);
        // scene.add(spotLight);
        // //
        // let directionalLight = new THREE.DirectionalLight(0xffffff,1.5);
        // directionalLight.position.set(500,700,500);
        // directionalLight.target.position.set(-500,0,-500);
        // directionalLight.castShadow = true;
        //directionalLight.shadow.camera.visible = true;
        // directionalLight.shadow.near =10;
        // directionalLight.shadow.far = 2000;
        //directionalLight.shadow.bias = 0.0001;
        // scene.add(directionalLight);
        // let  helper = new THREE.CameraHelper( directionalLight.shadow.camera );
        // scene.add(helper);
        //world geometry

        //cannon.js setup
        let physicWorld = new CANNON.World();
        physicWorld.gravity.set( 0 , -70 , 0 );
        physicWorld.broadphase = new CANNON.NaiveBroadphase();
        let physicGroundShape = new CANNON.Plane();
        let groundMaterial = new CANNON.Material();
        let objectMaterial = new CANNON.Material()
        let damping = 0.002;
        groundMaterial.friction = 0.3;
        let physicGround = new CANNON.Body({mass: 0 , shape: physicGroundShape , material: groundMaterial});
        physicWorld.add(physicGround);
        physicWorld.solver.iterations = 5;
        physicWorld.defaultContactMaterial.contactEquationStiffness = 1e6;
        physicWorld.defaultContactMaterial.contactEquationRelaxation = 10;
        let objToGround = new CANNON.ContactMaterial(groundMaterial, objectMaterial, { friction: 0.3, restitution: 0.4 });
        physicWorld.addContactMaterial(objToGround);

        function PlaneCanvas(filename) {
            let self=this;
            this.canvas = document.createElement("CANVAS");
            this.context = this.canvas.getContext("2d");
            this.image = document.createElement("IMG");
            this.loaded = false;
            this.image.src = filename;
            this.plane = null;
            this.image.onload = function() {
                self.canvas.width = self.image.width;
                self.canvas.height = self.image.height;
                self.context.drawImage(self.image, 0, 0);
                let planeGeometry = new THREE.PlaneGeometry(self.image.width , self.image.height);
                let planeMaterial = new THREE.MeshLambertMaterial( {color: 0xffffff, side: THREE.FrontSide} );
                let planeTexture = new THREE.Texture(self.canvas);
                planeTexture.needsUpdate = true;
                planeMaterial.map = planeTexture;
                self.plane = new THREE.Mesh( planeGeometry, planeMaterial );
                self.loaded = true;
            };
        }
        let worldPath = "world/world2/"
        worldTop = new PlaneCanvas(worldPath + "world_top.png");
        worldGround = new PlaneCanvas(worldPath + "world_ground.png");
        worldFront = new PlaneCanvas(worldPath + "world_front.png");
        worldBack = new PlaneCanvas(worldPath + "world_back.png");
        worldLeft = new PlaneCanvas(worldPath + "world_left.png");
        worldRight = new PlaneCanvas(worldPath + "world_right.png");
        function drawWorld(){
            h = worldFront.image.height / 2;
            worldTop.plane.rotation.x = Math.PI / 2;
            worldTop.plane.position.set(0 , h, 0);
            worldGround.plane.rotation.x = -1 * Math.PI/2;
            worldGround.plane.position.set(0,-h,0);
            //worldFront.plane.rotation.y = Math.PI/2;
            worldFront.plane.position.set(0,0,-h);
            worldBack.plane.rotation.y = Math.PI;
            worldBack.plane.position.set(0,0,h);
            worldLeft.plane.rotation.y = Math.PI/2;
            worldLeft.plane.position.set(-h,0,0);
            worldRight.plane.rotation.y = -1 * Math.PI/2;
            worldRight.plane.position.set(h,0,0);
            //
            //worldGround.plane.castShadow = true;
            worldGround.plane.receiveShadow  = true;

            scene.add(worldTop.plane);
            scene.add(worldGround.plane);
            scene.add(worldFront.plane);
            scene.add(worldBack.plane);
            scene.add(worldLeft.plane);
            scene.add(worldRight.plane);
        }
        let snake = {
            position: new THREE.Vector3(0,0,0),
            speed:50,
            turningSpeed:.9,
            direction: new THREE.Vector3(0,0,0),
            turningRight:false,
            turningLeft:false,
            movement:0,
            turningVector: new THREE.Vector3( 0 , 1 , 0),
            horizen: new THREE.Vector3( 1 , 0 , 0 ),
            update:function(){ 
                camera.rotateOnAxis( snake.horizen , -1 * gameSetting.lookUpAngle );
                if (snake.turningLeft){
                    camera.rotateOnAxis( snake.turningVector , Math.PI * dt * snake.turningSpeed );
                }
                if (snake.turningRight){
                    camera.rotateOnAxis( snake.turningVector, -1 * Math.PI * dt * snake.turningSpeed );
                }
                camera.rotateOnAxis( snake.horizen , gameSetting.lookUpAngle );
                camera.getWorldDirection(snake.direction);
                snake.movement=dt * snake.speed;
                snake.position.x+=snake.movement*snake.direction.x;
                snake.position.z+=snake.movement*snake.direction.z;
                camera.position.x=snake.position.x;
                camera.position.z=snake.position.z;
            },
        }
        function CubeObject(filename){
            let self = this;

            this.image = document.createElement("IMG");
            this.loaded = false;
            this.image.src = filename;
            this.mass = 1;
            // this.turningSpeed = 1;
            // this.turningVector = new THREE.Vector3( 0 , 1 , 0);
            let scale = .2;// times to actual size
            // Object.defineProperty(this , "scale",{
            //     get: function(){
            //         return scale;
            //         },
            //     set: function(value){
            //         scale = value;
            //     }
            // });
            this.threeBody = null;
            this.cannonBody = null;
            this.image.onload = function(){
                //three.js object
                let threeGeometry = new THREE.BoxGeometry(self.image.width * scale, self.image.height * scale , self.image.width * scale);
                let threeMaterial = new THREE.MeshLambertMaterial({color:0xffffff , side: THREE.FrontSide});
                let threeTexture = new THREE.Texture(self.image);
                threeTexture.needsUpdate = true;
                threeMaterial.map = threeTexture;
                self.threeBody = new THREE.Mesh( threeGeometry , threeMaterial );
                self.threeBody.castShadow = true;
                self.threeBody.receiveShadow  = true;
                //cannon.js object
                let cannonShape = new CANNON.Box(new CANNON.Vec3(self.image.width * scale / 2 , self.image.height * scale / 2 , self.image.width * scale / 2 ));
                self.cannonBody = new CANNON.Body({mass:self.mass , material: objectMaterial});
                self.cannonBody.linearDamping = damping;
                self.cannonBody.addShape(cannonShape);
                self.loaded = true;
            }
            this.addToWorlds = function(){
                scene.add(self.threeBody);
                physicWorld.addBody(self.cannonBody);
            }
            this.setPosition = function( x , y , z ){
                self.cannonBody.position.set( x , y , z );
                setThreePos();
            }
            this.update = function(){
                if (self.loaded){
                    setThreePos();
                    //self.threeBody.rotateOnAxis( self.turningVector , self.turningSpeed * Math.PI * dt);
                }
            }
            let setThreePos = function(){
                setBodyPos(self.threeBody , self.cannonBody);
            }
            
        }



        let gameSetting = {
            viewPointHeight: 0.05, //snake height from ground in percent of world height ( 0 to 1 )
            lookUpAngle: 0 //camera head up angle during walking eg. Math.PI/8
        }
        function setBodyPos(body1,body2){
            body1.position.x = body2.position.x;
            body1.position.y = body2.position.y;
            body1.position.z = body2.position.z;
            body1.quaternion.x = body2.quaternion.x;
            body1.quaternion.y = body2.quaternion.y;
            body1.quaternion.z = body2.quaternion.z;
            body1.quaternion.w = body2.quaternion.w;

        }
        function gamePlot(){

        }  

                        //
                // cube1.addToWorlds();
                // cube1.setPosition(0,-700,-700);
        function initializeGame(){
            drawWorld();
            setBodyPos(physicGround,worldGround.plane);
            camera.position.set( 0 , -1 * (worldFront.image.height / 2 ) * (1 - gameSetting.viewPointHeight) , 0 ); //a bit higher than ground
            camera.rotateOnAxis(new THREE.Vector3(1,0,0) , gameSetting.lookUpAngle); // a bit look up
            snake.position=camera.position;
            document.addEventListener( "keydown" , keyDownHandler , false );
            document.addEventListener( "keyup" , keyUpHandler , false );
            initialized = true;
        }
        function keyDownHandler ( e ){
            if (e.key == "Right" || e.key == "ArrowRight" ){
                if( !snake.turningRight ){
                    snake.turningLeft = false;
                    snake.turningRight = true;
                }
            }
            else if (e.key == "Left" || e.key == "ArrowLeft"){
                if( !snake.turningLeft ){
                    snake.turningRight = false;
                    snake.turningLeft = true;
                }
            }
        }
        function keyUpHandler ( e ){
            if (e.key == "Right" || e.key == "ArrowRight" ){
                    snake.turningRight = false;
            }
            else if (e.key == "Left" || e.key == "ArrowLeft"){
                    snake.turningLeft = false;
            }
        }
        let lastTime = undefined;
        let timeStep = 1/60;
        let maxSubStep = 3;
        let initialized = false;
        let dt = 0;
        let update = function () {
            if (initialized){
                snake.update();
                camera.updateProjectionMatrix();
                gamePlot();
            }
                //
                // delta +=.005;
                // camera.position.set(Math.sin(delta) * 512,-500,Math.cos(delta) * 512);
                // //camera.lookAt(Math.sin(delta) * 512 ,0 , Math.cos(delta) * 512);
                // camera.lookAt(new THREE.Vector3(0,-410,0));
                // camera.updateProjectionMatrix();
                
            };
        let render = function ( ) {
            renderer.render( scene , camera);
        };

        function mainloop(timeStamp){
            if (lastTime == undefined){
                lastTime = timeStamp;
                requestAnimationFrame(mainloop);
                return;
            }
            if (worldTop.loaded && worldGround.loaded && worldFront.loaded && worldBack.loaded && worldLeft.loaded && worldRight.loaded && !initialized){
                    initializeGame();
            }

            dt += (timeStamp - lastTime) / 1000;
            if (dt>=1/120){
                physicWorld.step( timeStep , dt , maxSubStep );
                update ();
                render ();
                dt=0;
            }

            lastTime = timeStamp;
            requestAnimationFrame (mainloop);
        }
        requestAnimationFrame(mainloop);
    </script>
        
</body>
</html>